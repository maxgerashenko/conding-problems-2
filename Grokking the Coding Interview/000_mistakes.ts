// sort T:O(NlogN) S(N)
// minHeap insert T:(log K) S:(K)
// minHeap all el NlogK if it's limited by K at once

// if(pre && pre.val === key) return node;
// sort (x.start, y.start) => s.start - y.start
// this.
// class Heap {
// max = Math.max
// for in i; +i
// for in i: skip [null, 1]
// this.arr.sort, but this.arr = this.arr.filter

// Subsets

// Binary search
//  Problem: Math.floor selects left side
//      FIstart = mid+1 or end = mid-1
