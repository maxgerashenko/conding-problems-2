// sort T:O(NlogN) S(N)
// minHeap insert T:(log K) S:(K)
// minHeap all el NlogK if it's limited by K at once

// if(pre && pre.val === key) return node;
// sort (x.start, y.start) => s.start - y.start
// this.
// class Heap {
// max = Math.max
// for in i; +i
// for in i: skip [null, 1]
